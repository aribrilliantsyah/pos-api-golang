// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: report.sql

package db

import (
	"context"
	"database/sql"
)

const getAllOrders = `-- name: GetAllOrders :many
SELECT 
    o.id, o.trx_number, o.cashier_id, o.customer_id, o.total_amount, o.payment_method, o.status, o.order_date, o.updated_by, o.updated_at,
    c.name as customer_name,
    u.username as cashier_name
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.id
LEFT JOIN users u ON o.cashier_id = u.id
ORDER BY o.order_date DESC
LIMIT $1 OFFSET $2
`

type GetAllOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllOrdersRow struct {
	ID            int64          `json:"id"`
	TrxNumber     string         `json:"trx_number"`
	CashierID     sql.NullInt64  `json:"cashier_id"`
	CustomerID    sql.NullInt64  `json:"customer_id"`
	TotalAmount   string         `json:"total_amount"`
	PaymentMethod string         `json:"payment_method"`
	Status        string         `json:"status"`
	OrderDate     sql.NullTime   `json:"order_date"`
	UpdatedBy     sql.NullInt64  `json:"updated_by"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	CustomerName  sql.NullString `json:"customer_name"`
	CashierName   sql.NullString `json:"cashier_name"`
}

func (q *Queries) GetAllOrders(ctx context.Context, arg GetAllOrdersParams) ([]GetAllOrdersRow, error) {
	rows, err := q.query(ctx, q.getAllOrdersStmt, getAllOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllOrdersRow{}
	for rows.Next() {
		var i GetAllOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TrxNumber,
			&i.CashierID,
			&i.CustomerID,
			&i.TotalAmount,
			&i.PaymentMethod,
			&i.Status,
			&i.OrderDate,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CustomerName,
			&i.CashierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastMovingProducts = `-- name: GetFastMovingProducts :many

SELECT 
    p.id,
    p.name,
    p.category_id,
    c.name as category_name,
    COALESCE(SUM(oi.quantity), 0) as total_quantity,
    COALESCE(COUNT(DISTINCT o.id), 0) as total_orders
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND
    (o.order_date >= $1 AND  o.order_date < $2) AND
    o.status = 'order'
LEFT JOIN categories c ON p.category_id = c.id
GROUP BY p.id, p.name, p.category_id, c.name
ORDER BY total_quantity DESC
LIMIT 10
`

type GetFastMovingProductsParams struct {
	OrderDate   sql.NullTime `json:"order_date"`
	OrderDate_2 sql.NullTime `json:"order_date_2"`
}

type GetFastMovingProductsRow struct {
	ID            int64          `json:"id"`
	Name          string         `json:"name"`
	CategoryID    sql.NullInt64  `json:"category_id"`
	CategoryName  sql.NullString `json:"category_name"`
	TotalQuantity interface{}    `json:"total_quantity"`
	TotalOrders   interface{}    `json:"total_orders"`
}

func (q *Queries) GetFastMovingProducts(ctx context.Context, arg GetFastMovingProductsParams) ([]GetFastMovingProductsRow, error) {
	rows, err := q.query(ctx, q.getFastMovingProductsStmt, getFastMovingProducts, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFastMovingProductsRow{}
	for rows.Next() {
		var i GetFastMovingProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
			&i.TotalQuantity,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, trx_number, cashier_id, customer_id, total_amount, payment_method, status, order_date, updated_by, updated_at FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TrxNumber,
		&i.CashierID,
		&i.CustomerID,
		&i.TotalAmount,
		&i.PaymentMethod,
		&i.Status,
		&i.OrderDate,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const getSlowMovingProducts = `-- name: GetSlowMovingProducts :many
SELECT 
    p.id,
    p.name,
    p.category_id,
    c.name as category_name,
    COALESCE(SUM(oi.quantity), 0) as total_quantity,
    COALESCE(COUNT(DISTINCT o.id), 0) as total_orders
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND
    (o.order_date >= $1 AND  o.order_date < $2) AND
    o.status = 'order'
LEFT JOIN categories c ON p.category_id = c.id
GROUP BY p.id, p.name, p.category_id, c.name
ORDER BY total_quantity ASC
LIMIT 10
`

type GetSlowMovingProductsParams struct {
	OrderDate   sql.NullTime `json:"order_date"`
	OrderDate_2 sql.NullTime `json:"order_date_2"`
}

type GetSlowMovingProductsRow struct {
	ID            int64          `json:"id"`
	Name          string         `json:"name"`
	CategoryID    sql.NullInt64  `json:"category_id"`
	CategoryName  sql.NullString `json:"category_name"`
	TotalQuantity interface{}    `json:"total_quantity"`
	TotalOrders   interface{}    `json:"total_orders"`
}

func (q *Queries) GetSlowMovingProducts(ctx context.Context, arg GetSlowMovingProductsParams) ([]GetSlowMovingProductsRow, error) {
	rows, err := q.query(ctx, q.getSlowMovingProductsStmt, getSlowMovingProducts, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSlowMovingProductsRow{}
	for rows.Next() {
		var i GetSlowMovingProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
			&i.TotalQuantity,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCashiers = `-- name: GetTopCashiers :many
SELECT 
    u.id as cashier_id,
    u.username,
    u.full_name,
    COUNT(DISTINCT o.id) as total_orders,
    SUM(o.total_amount) as total_amount,
    AVG(o.total_amount) as average_order_amount
FROM users u
JOIN orders o ON u.id = o.cashier_id
WHERE 
    (o.order_date >= $1 AND  o.order_date < $2) AND
    o.status = 'order'
GROUP BY u.id, u.username, u.full_name
ORDER BY total_amount DESC
LIMIT 10
`

type GetTopCashiersParams struct {
	OrderDate   sql.NullTime `json:"order_date"`
	OrderDate_2 sql.NullTime `json:"order_date_2"`
}

type GetTopCashiersRow struct {
	CashierID          int64   `json:"cashier_id"`
	Username           string  `json:"username"`
	FullName           string  `json:"full_name"`
	TotalOrders        int64   `json:"total_orders"`
	TotalAmount        int64   `json:"total_amount"`
	AverageOrderAmount float64 `json:"average_order_amount"`
}

func (q *Queries) GetTopCashiers(ctx context.Context, arg GetTopCashiersParams) ([]GetTopCashiersRow, error) {
	rows, err := q.query(ctx, q.getTopCashiersStmt, getTopCashiers, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopCashiersRow{}
	for rows.Next() {
		var i GetTopCashiersRow
		if err := rows.Scan(
			&i.CashierID,
			&i.Username,
			&i.FullName,
			&i.TotalOrders,
			&i.TotalAmount,
			&i.AverageOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCustomers = `-- name: GetTopCustomers :many
SELECT 
    c.id as customer_id,
    c.member_code,
    c.name,
    c.phone,
    c.email,
    COUNT(DISTINCT o.id) as total_orders,
    SUM(o.total_amount)::DECIMAL as total_spent,
    AVG(o.total_amount) as average_order_amount
FROM customers c
JOIN orders o ON c.id = o.customer_id
WHERE 
    (o.order_date >= $1 AND  o.order_date < $2) AND
    o.status = 'order'
GROUP BY c.id, c.member_code, c.name, c.phone, c.email
ORDER BY total_spent DESC
LIMIT 10
`

type GetTopCustomersParams struct {
	OrderDate   sql.NullTime `json:"order_date"`
	OrderDate_2 sql.NullTime `json:"order_date_2"`
}

type GetTopCustomersRow struct {
	CustomerID         int64          `json:"customer_id"`
	MemberCode         string         `json:"member_code"`
	Name               string         `json:"name"`
	Phone              sql.NullString `json:"phone"`
	Email              sql.NullString `json:"email"`
	TotalOrders        int64          `json:"total_orders"`
	TotalSpent         string         `json:"total_spent"`
	AverageOrderAmount float64        `json:"average_order_amount"`
}

func (q *Queries) GetTopCustomers(ctx context.Context, arg GetTopCustomersParams) ([]GetTopCustomersRow, error) {
	rows, err := q.query(ctx, q.getTopCustomersStmt, getTopCustomers, arg.OrderDate, arg.OrderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopCustomersRow{}
	for rows.Next() {
		var i GetTopCustomersRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.MemberCode,
			&i.Name,
			&i.Phone,
			&i.Email,
			&i.TotalOrders,
			&i.TotalSpent,
			&i.AverageOrderAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
